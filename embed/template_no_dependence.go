package embed

const templateNoDependence = `// Code generated by shures; DO NOT EDIT.
package {{ .Package }}

{{- with $model := . }}

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"os"
	"path"
	"sync"
	"time"
)

var {{ $model.Name }} = &{{ $model.FSType }}{
	Files: {{ $model.VarFiles }},
	Dirs:  {{ $model.VarDirs }},
}

var {{ $model.VarFiles }} = {{ $model.FileMapType }}{
{{- range $dir := $model.Folders }}
	"{{ $dir.Path }}": {
	    Path:        "{{ $dir.Path }}",
	    FileName:    "{{ $dir.FileName }}",
	    FileIsDir:   true,
    },
    {{- range (index $model.FileMap $dir.Path) }}
	"{{ .Path }}": {
	    Path:        "{{ .Path }}",
	    FileName:    "{{ .FileName }}",
	    FileSize:    {{ .FileSize  }},
	    FileModTime: {{ .FileModTime }},
	    Compressed:  ` + "`" + `{{ .Compressed }}` + "`" + `,
    },
	{{- end }}
{{- end }}
}

var {{ $model.VarDirs }} = {{ $model.DirMapType }}{
{{- range $dir := $model.Folders }}
	"{{ $dir.Path }}": {
		{{- range (index $model.FileMap $dir.Path) }}
		{{ $model.VarFiles }}["{{ .Path }}"],
		{{- end }}
	},
{{- end }}
}

type (
	{{ $model.FileMapType }} map[string]*{{ $model.FileType }}
	{{ $model.DirMapType }} map[string][]os.FileInfo

	{{ $model.HttpFileType }} struct {
		*{{ $model.FSType }}
		*{{ $model.FileType }}
		*bytes.Reader
	}

	{{ $model.FSType }} struct {
		Files {{ $model.FileMapType }}
		Dirs  {{ $model.DirMapType }}
	}

	{{ $model.FileType }} struct {
		Path        string
		Compressed  string
		FileName    string
		FileIsDir   bool
		FileSize    int
		FileModTime int64
		data     []byte
		prepared bool
		err      error
		locker   sync.Mutex
	}
)

/* FS */

func (fs *{{ $model.FSType }}) Open(name string) (http.File, error) {
	f, find := fs.Files[path.Clean(name)]
	if !find {
		return nil, os.ErrNotExist
	}

	if f.prepare(); f.err != nil {
		return nil, f.err
	}

	return &{{ $model.HttpFileType }}{
		FS:     fs,
		File:   f,
		Reader: bytes.NewReader(f.data),
	}, nil
}

/* File */

func (f *{{ $model.FileType }}) Name() string {
	return f.FileName
}

func (f *{{ $model.FileType }}) Size() int64 {
	return int64(f.FileSize)
}

func (f *{{ $model.FileType }}) Mode() os.FileMode {
	return 0444
}

func (f *{{ $model.FileType }}) ModTime() time.Time {
	return time.Unix(f.FileModTime, 0)
}

func (f *{{ $model.FileType }}) IsDir() bool {
	return f.FileIsDir
}

func (f *{{ $model.FileType }}) Sys() interface{} {
	return f
}

func (f *{{ $model.FileType }}) Bytes() ([]byte, error) {
	f.prepare()
	return f.data, f.err
}

func (f *{{ $model.FileType }}) prepare() {
	f.locker.Lock()
	defer f.locker.Unlock()
	if !f.prepared {
		f.prepared = true
		if f.FileSize > 0 {
			gr, err := gzip.NewReader(base64.NewDecoder(base64.StdEncoding, bytes.NewBufferString(f.Compressed)))
			if err != nil {
				f.err = err
				return
			}
			f.data, f.err = ioutil.ReadAll(gr)
		}
	}
}

/* HttpFile */

func (f *{{ $model.HttpFileType }}) Close() error {
	return nil
}

func (f *{{ $model.HttpFileType }}) Readdir(count int) ([]os.FileInfo, error) {
	if !f.FileIsDir {
		return nil, fmt.Errorf("go.res.Readdir: '%s' is not directory", f.FileName)
	}

	fis, ok := f.Dirs[f.Path]
	if !ok {
		return nil, fmt.Errorf("go.res.Readdir: '%s' is directory, but we have no info about content of this dir, local=%s", f.FileName, f.Path)
	}
	limit := count
	if count <= 0 || limit > len(fis) {
		limit = len(fis)
	}

	if len(fis) == 0 && count > 0 {
		return nil, io.EOF
	}

	return fis[0:limit], nil
}

func (f *{{ $model.HttpFileType }}) Stat() (os.FileInfo, error) {
	return f.{{ $model.FileType }}, nil
}

{{- end }}
`
