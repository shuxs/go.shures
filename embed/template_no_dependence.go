package embed

const templateNoDependence = `// Code generated by shures; DO NOT EDIT.
package {{ .pkg }}

{{- with $model := . }}

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"os"
	"path"
	"sync"
	"time"
)

var (
	_ http.FileSystem = &_{{ $model.var }}FS{}
	_ os.FileInfo     = &_{{ $model.var }}File{}
	_ http.File       = &_{{ $model.var }}HttpFile{}
)

type (
	_{{ $model.var }}FileMap map[string]*_{{ $model.var }}File
	_{{ $model.var }}DirMap  map[string][]os.FileInfo

	_{{ $model.var }}HttpFile struct {
		*_{{ $model.var }}FS
		*_{{ $model.var }}File
		*bytes.Reader
	}

	_{{ $model.var }}FS struct {
		Files _{{ $model.var }}FileMap
		Dirs  _{{ $model.var }}DirMap
	}

	_{{ $model.var }}File struct {
		Path        string //文件路径
		Compressed  string //压缩编码后的字符串
		FileName    string //文件名
		FileIsDir   bool   //是否目录
		FileSize    int    //文件大小
		FileModTime int64  //文件修改时间

		ChildPaths []string
		once       sync.Once
		data       []byte //文件数据
	}
)

func (fs *_{{ $model.var }}FS) prepare(name string) (*_{{ $model.var }}File, error) {
	f, present := fs.Files[path.Clean(name)]
	if !present {
		return nil, os.ErrNotExist
	}
	var err error
	f.once.Do(func() {
		if f.FileSize == 0 {
			return
		}
		var gr *gzip.Reader
		var bReader = base64.NewDecoder(base64.StdEncoding, bytes.NewBufferString(f.Compressed))
		if gr, err = gzip.NewReader(bReader); err != nil {
			return
		}
		f.data, _ = ioutil.ReadAll(gr)
	})
	if err != nil {
		return nil, err
	}
	return f, nil
}

func (fs *_{{ $model.var }}FS) Open(name string) (http.File, error) {
	f, err := fs.prepare(name)
	if err != nil {
		return nil, err
	}
	return f.File(fs)
}

func (f *_{{ $model.var }}File) Name() string {
	return f.FileName
}

func (f *_{{ $model.var }}File) Size() int64 {
	return int64(f.FileSize)
}

func (f *_{{ $model.var }}File) Mode() os.FileMode {
	return 0444
}

func (f *_{{ $model.var }}File) ModTime() time.Time {
	return time.Unix(f.FileModTime, 0)
}

func (f *_{{ $model.var }}File) IsDir() bool {
	return f.FileIsDir
}

func (f *_{{ $model.var }}File) Sys() interface{} {
	return f
}

func (f *_{{ $model.var }}File) File(fs *_{{ $model.var }}FS) (http.File, error) {
	return &_{{ $model.var }}HttpFile{
		_{{ $model.var }}FS:   fs,
		_{{ $model.var }}File: f,
		Reader:      bytes.NewReader(f.data),
	}, nil
}

func (f *_{{ $model.var }}HttpFile) Close() error {
	return nil
}

func (f *_{{ $model.var }}HttpFile) Readdir(count int) ([]os.FileInfo, error) {
	if !f.FileIsDir {
		return nil, fmt.Errorf("go.res.Readdir: '%s' is not directory", f.FileName)
	}

	fis, ok := f.Dirs[f.Path]
	if !ok {
		return nil, fmt.Errorf("go.res.Readdir: '%s' is directory, but we have no info about content of this dir, local=%s", f.FileName, f.Path)
	}
	limit := count
	if count <= 0 || limit > len(fis) {
		limit = len(fis)
	}

	if len(fis) == 0 && count > 0 {
		return nil, io.EOF
	}

	return fis[0:limit], nil
}

func (f *_{{ $model.var }}HttpFile) Stat() (os.FileInfo, error) {
	return f._{{ $model.var }}File, nil
}

var {{ $model.var }} = &_{{ $model.var }}FS{
	Files: _{{ $model.var }}Files,
	Dirs:  _{{ $model.var }}Dirs,
}

var _{{ $model.var }}Files = _{{ $model.var }}FileMap{
{{- range $dir := $model.dirs }}
	"{{ $dir.Path }}": {
	    Path:        "{{ $dir.Path }}",
	    FileName:    "{{ $dir.FileName }}",
	    FileIsDir:   true,
    },
    {{- range (index $model.files $dir.Path) }}
	"{{ .Path }}": {
	    Path:        "{{ .Path }}",
	    FileName:    "{{ .FileName }}",
	    FileSize:    {{ .FileSize  }},
	    FileModTime: {{ .FileModTime }},
	    Compressed:  ` + "`" + `{{ .Compressed }}` + "`" + `,
    },
	{{- end }}
{{- end }}
}

var _{{ $model.var }}Dirs = _{{ $model.var }}DirMap{
{{- range $dir := $model.dirs }}
	"{{ $dir.Path }}": {
		{{- range (index $model.files $dir.Path) }}
		_{{ $model.var }}Files["{{ .Path }}"],
		{{- end }}
	},
{{- end }}
}
{{- end }}
`
